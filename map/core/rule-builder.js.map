{"version":3,"sources":["core/rule-builder.coffee"],"names":[],"mappings":"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","file":"core/rule-builder.js","sourceRoot":"/source/","sourcesContent":["{Def} = require './token'\n# {RuleBuilder} is used by {LanguagePack} internally to compile rules for parser\n# to execute.\n#\n# ## Terminology\n#\n# * **Rule decleration**s are made with API calls in {LanguagePack} to specify\n#   the syantax of a language feature with regex as well as how relevent data is\n#   captured and emitted into tokens.\n# * **Rule**s are compiled declarations each of which consists of a regex and a\n#   handler function. The latter emits a token or manipulates the parent token.\n#\n# For more information on how to decalre a rule, see {LanguagePack}.\nmodule.exports =\nclass RuleBuilder\n  constructor: ->\n    @_aliasMap = {}\n    @_subRules = {}\n\n  declareAlias: (alias, regex) ->\n    # TODO: check for duplication\n    @_aliasMap[alias] = regex\n\n  declareSubRule: (name, rule, capture_map) ->\n    # TODO: check for name duplication\n    compiled = @_compileRule(rule, capture_map)\n    @_subRules[name] = compiled\n\n  # @private\n  #\n  # Get the string representation of a regex part for concatenatiion.\n  #\n  # @overload _getRegexPart(alias_or_literal)\n  #   The argument is searched in the alias map first, then in the sub-rule map.\n  #   If no match is found, it\n  #   is then considered as a literal regex source string.\n  #   The literal string will be escaped. For example, `'^[()]'` is processed to\n  #   `/\\^\\[\\(\\)\\]/`.\n  #   @param [string] alias_or_literal\n  # @overload _getRegexPart(regex)\n  #   @param [RegExp] regex\n  # @return [string] Regex part's string source\n  _getRegexPart: (r) ->\n    escape_r = /[-\\/\\\\^$*+?.()|[\\]{}]/g\n    t = typeof r\n    if t == 'string'\n      if r of @_aliasMap\n        # Alias\n        return {type: 'alias', rule: @_aliasMap[r]}\n      if r of @_subRules\n        # Sub-rule\n        return {type: 'sub', rule: @_subRules[r]}\n      # Literal\n      return {type: 'literal', rule: r.replace(escape_r, '\\\\$&')}\n    else if t == 'object' and r instanceof RegExp\n      return {type: 'regex', rule: r.source}\n    throw new TypeError(\"#{r} is not a valid alias name, string or RegExp\")\n\n  _makeMatchHandler: (token_defs) ->\n    return (node, matches) ->\n      for d in token_defs\n        payload = match = matches[d.group_index]\n        if d.transform?\n          payload = d.transform(payload)\n\n        node[d.id] = payload\n        # TODO: use node.attachXxx accroding to d.type field\n\n  # @private\n  # Compile rules\n  # @param {Array<RegExp|string>} rule\n  # @param {Object} capture_map\n  # @return {Object}\n  _compileRule: (rule, capture_map) ->\n    regex_src = ''\n    group_index = 0\n    token_defs = []\n    in_optional_group = false\n    current_optional_group = \"\"\n\n    for r, i in rule\n      token_def = capture_map?[i + 1]\n\n      could_capture = token_def?\n\n      part = @_getRegexPart(r)\n      part_src = part.rule\n\n      if part.type == 'sub'\n        if could_capture\n          err = new TypeError(\"Sub-rules cannot be re-captured\")\n          err.ruleName = r\n          err.ruleIndex = i\n          throw err\n        regex_src += part.rule.regex.source\n        # Flatten part.token_defs\n        base_group_index = group_index\n        for sub_def in part.rule.token_defs\n          copied = Def.clone(sub_def)\n          current_group_index = base_group_index + sub_def.group_index\n          copied.group_index = current_group_index\n          group_index = current_group_index\n          token_defs.push copied\n      else\n        if could_capture\n          lazy_leaving = in_optional_group and not token_def.optional?\n          optional_changing = (token_def.optional ? false) != in_optional_group\n          if lazy_leaving or optional_changing\n            if not in_optional_group\n              # false -> true, entering optional group\n              group_index++\n              in_optional_group = true\n            else\n              # true -> false, leaving optional group\n              in_optional_group = false\n              regex_src += \"(#{current_optional_group})?\"\n              current_optional_group = \"\"\n          if token_def.type != Def.Nothing\n            group_index++\n            part_src = \"(#{part.rule})\"\n            token_defs.push token_def\n            token_def.group_index = group_index\n        else if in_optional_group\n          # true -> false, leaving optional group\n          in_optional_group = false\n          regex_src += \"(#{current_optional_group})?\"\n          current_optional_group = \"\"\n        # Accumulate source\n        if in_optional_group\n          current_optional_group += part_src\n        else\n          regex_src += part_src\n\n    compiled =\n      regex: new RegExp(regex_src)\n      token_defs: token_defs\n\n    return compiled\n\n  # @param {Array<RegExp|string>} rule\n  # @param {Object} capture_map\n  make: (rule, capture_map) ->\n    compiled = @_compileRule(rule, capture_map)\n\n    result =\n      regex: compiled.regex\n      handler: @_makeMatchHandler(compiled.token_defs)\n    return result\n"]}