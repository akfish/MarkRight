{"version":3,"sources":["compiler/parser.coffee"],"names":[],"mappings":"AAiIA,IAAA,MAAA;;AAAA,MAAM,CAAC,OAAP,GACM;AAES,EAAA,gBAAA,GAAA,CAAb;;AAAA,mBAKA,KAAA,GAAO,SAAC,GAAD,GAAA;AACL,QAAA,GAAA;AAAA,IAAA,GAAA,GAAM,IAAC,CAAA,YAAD,CAAc,GAAd,CAAN,CAAA;AAAA,IACA,GAAA,GAAM,IAAC,CAAA,YAAD,CAAc,GAAd,CADN,CAAA;AAGA,WAAO,GAAP,CAJK;EAAA,CALP,CAAA;;AAAA,mBAeA,YAAA,GAAc,SAAC,GAAD,GAAA;AACZ,QAAA,2GAAA;AAAA,IAAA,MAAA,GAAS,CAAT,CAAA;AAAA,IACA,CAAA,GAAI,GAAG,CAAC,MADR,CAAA;AAAA,IAEA,OAAA,GAAU,EAFV,CAAA;AAAA,IAGA,GAAA,GAAM,EAHN,CAAA;AAKA,WAAM,MAAA,GAAS,CAAT,IAAc,OAAO,CAAC,MAAR,GAAiB,CAArC,GAAA;AACE,MAAA,UAAA,GAAa,MAAb,CAAA;AAAA,MACA,cAAA,GAAiB,IAAC,CAAA,kCAAD,CAAoC,MAApC,EAA4C,GAA5C,CADjB,CAAA;AAAA,MAEA,SAAA,GAAY,cAAc,CAAC,UAF3B,CAAA;AAGA,MAAA,IAAG,sBAAH;AACE,QAAA,cAAA,GAAiB,IAAC,CAAA,kBAAD,CAAoB,UAApB,EAAgC,SAAhC,EAA2C,GAA3C,CAAjB,CAAA;AAAA,QACA,OAA2B,IAAC,CAAA,kBAAD,CAAoB,cAApB,EAAoC,GAApC,CAA3B,EAAC,cAAA,MAAD,EAAS,sBAAA,cADT,CADF;OAAA,MAAA;AAIE,QAAA,QAA2B,IAAC,CAAA,kBAAD,CAAoB,UAApB,EAAgC,CAAhC,EAAmC,GAAnC,CAA3B,EAAC,eAAA,MAAD,EAAS,uBAAA,cAAT,CAJF;OAHA;AAAA,MASA,GAAG,CAAC,IAAJ,CAAS,cAAT,CATA,CAAA;AAAA,MAUA,GAAG,CAAC,IAAJ,CAAS,cAAT,CAVA,CADF;IAAA,CALA;AAkBA,WAAO,GAAP,CAnBY;EAAA,CAfd,CAAA;;AAAA,mBA0CA,iCAAA,GAAmC,SAAC,MAAD,EAAS,GAAT,GAAA,CA1CnC,CAAA;;AAAA,mBAkDA,kBAAA,GAAoB,SAAC,KAAD,EAAQ,GAAR,EAAa,GAAb,GAAA;AAClB,QAAA,sCAAA;AAAA,IAAA,KAAA,GAAQ,IAAC,CAAA,gBAAD,CAAkB,KAAlB,EAAyB,GAAzB,EAA8B,GAA9B,CAAR,CAAA;AAAA,IACA,eAAA,GAAkB,IAAC,CAAA,kBAAD,CAAoB,KAApB,EAA2B,KAAK,CAAC,UAAN,GAAmB,CAA9C,EAAiD,GAAjD,CADlB,CAAA;AAAA,IAEA,cAAA,GAAkB,IAAC,CAAA,kBAAD,CAAoB,KAAK,CAAC,SAA1B,EAAqC,GAArC,EAA0C,GAA1C,CAFlB,CAAA;AAIA,WAAO,EAAE,CAAC,MAAH,CAAU,eAAV,EAA2B,KAA3B,EAAkC,cAAlC,CAAP,CALkB;EAAA,CAlDpB,CAAA;;AAAA,mBA8DA,kBAAA,GAAoB,SAAC,WAAD,EAAc,GAAd,GAAA,CA9DpB,CAAA;;AAAA,mBAuEA,gBAAA,GAAkB,SAAA,GAAA;WAAG,SAAC,KAAD,EAAQ,GAAR,EAAa,GAAb,GAAA,EAAH;EAAA,CAvElB,CAAA;;AAAA,mBA8EA,YAAA,GAAc,SAAC,GAAD,GAAA,CA9Ed,CAAA;;gBAAA;;IAHF,CAAA","file":"compiler/parser.js","sourceRoot":"/source/","sourcesContent":["# The parser processes input Markdown source and generates AST\n# (abastract syntax tree) for the generator to consume.\n#\n# ## Terminology\n#\n# * **Documents** are top level representations of parsed Markdown files.\n# * **Solid blocks** are continuous document parts consist of only leaf blocks.\n# * **Fluid blocks** are continuous document parts that contains contents of\n#   container blocks with closing elements yet to be determined.\n#\n# See {LanguagePack} for language spec related terminology.\n#\n# ## Parsing Strategy\n#\n# The parser applies rules in a determined order (a.k.a. precedence) to avoid\n# any ambiguity. The elements take their precedence in following order:\n#\n# 1. Container blocks\n# 2. Leaf blocks\n# 3. Inline elements\n#\n# The parser processes a document in 2 passes:\n#\n# 1. Determine block structures and assign un-parsed source to each block tokens\n# 2. Parse inline tokens of each blocks\n#\n# ### Block Parsing\n#\n# Block parsing is implemented in {Parser#_parseBlocks}.\n# Unlike other Markdown parser implementations, MarkRight parser does\n# not require matched rules to be anchored at the begining of the stream.\n# Instead, {Parser#___parseOneBlock} applies rules from highest precedence to\n# lowest and returns the first match no matter where the match's location is.\n#\n# It is expeced that the first match usually occurs in the middle thus spliting\n# the stream into three parts:\n#\n# ```\n# +---------------------------+ Document Begin\n# |                           |\n# |                           |\n# |        Parsed             |\n# |                           |\n# |                           |\n# +---------------------------+ Offset\n# |                           |\n# |                           |\n# |       Residual Before     |\n# |                           |\n# |                           |\n# +---------------------------+\n# |                           |\n# |       First Match         |\n# |                           |\n# +---------------------------+\n# |                           |\n# |                           |\n# |                           |\n# |       Residual After      |\n# |                           |\n# |                           |\n# |                           |\n# |                           |\n# +---------------------------+ Document End\n# ```\n#\n# If the `First Match` is a leaf block, the parser can safely assume that the\n# entire stream is one solid block. Hence both residual blocks are solid too.\n# Thus the parsing can be achived by recusively parse and split the stream into\n# smaller and smaller blocks until the entire stream is parsed.\n# This is done by {Parser#__parseSolidBlocks}.\n#\n# If the `First Match` is a container block start token, the `Residual Before`\n# is known to be a solid block and can be parsed with\n# {Parser#__parseSolidBlocks}.\n# The `Residual After` would be a fluid block:\n#\n# ```\n# +---------------------------+\n# |                           |\n# |       First Match         | <---+ Container block start token\n# |                           |       (e.g. '> ' for a blockquote)\n# +---------------------------+\n# X                           X\n# X       Content of          X <---+ Residual After (Fluid Block)\n# X       Container Block     X\n# X                           X\n# X---------------------------X ----> New offset for next iteration\n# X                           X\n# X       Un-parsed           X\n# X                           X\n# +---------------------------+ Document End\n# ```\n#\n# A fluid block is parsed by {Parser#__parseFluidBlocks}. It parses the fluid\n# block linearly and looks for lines start with content block delimiter (e.g.\n# '> ' for blockquotes or correct level of indentation for list items).\n# Delimiters are stripped before the contents are aggregated into one new block\n# for later parsing. A new line without a container block delimiter can either\n# be the end of current container block or should be added to the container\n# accroding to 'laziness' rule. The parsing is not complete until either the end\n# of container block or the end of the document is encountered.\n#\n# ```\n# +---+----------------------+\n# |   |                      |\n# | * | Content              |\n# |   |                      |\n# +---+----------------------+ <--+ Possible end of content block\n# |                          |\n# |     Next element without |\n# |     delimiter            |\n# |                          |\n# +--------------------------+\n# |                          |\n# |     Un-parsed            |\n# |                          |\n# +--------------------------+\n#\n# * Container block delimiter\n# ```\n#\n# After each iteration, the `offset` is advanced and the whole process starts\n# again until the end of the document.\n#\n# ### Inline Element Parsing\n#\n# Inline element parsing ({Parser#_parseInline}) is trival.\n# The stategy is exactly the same as solid block parsing.\nmodule.exports =\nclass Parser\n  # Create a {Parser} instance\n  constructor: ->\n\n  # Parse Markdown source into AST\n  # @param {string} src Markdown source\n  # @return {Array} AST\n  parse: (src) ->\n    ast = @_parseBlocks(src)\n    ast = @_parseInline(ast)\n\n    return ast\n\n  # @private\n  # Parse block structures\n  # @param {string} src Markdown source\n  # @return {Array} AST\n  _parseBlocks: (src) ->\n    offset = 0\n    n = src.length\n    pending = []\n    ast = []\n\n    while offset < n or pending.length > 0\n      startIndex = offset\n      cb_start_token = @__tryParseContainerBlockStartToken(offset, src)\n      lastIndex = cb_start_token.startIndex\n      if cb_start_token?\n        ast_solid_part = @__parseSolidBlocks(startIndex, lastIndex, src)\n        {offset, ast_fluid_part} = @__parseFluidBlocks(cb_start_token, src)\n      else\n        {offset, ast_solid_part} = @__parseSolidBlocks(startIndex, n, src)\n\n      ast.push ast_solid_part\n      ast.push ast_fluid_part\n\n    return ast\n\n  # @private\n  # Parse the source starting from given offset and tries to find the first\n  # container block start token\n  # @param {int} offset Offset value\n  # @param {string} src Markdown source\n  # @return {Token} Matched token (nullable)\n  _tryParseContainerBlockStartToken: (offset, src) ->\n\n  # @private\n  # Parse the specified document region as a solid block\n  # @param {int} begin Start index of the region\n  # @param {int} end Last index of the region\n  # @param {src} src Markdown source\n  # @return [Array<Token>] AST of specified region\n  __parseSolidBlocks: (begin, end, src) ->\n    block = @___parseOneBlock(begin, end, src)\n    ast_part_before = @__parseSolidBlocks(begin, block.startIndex - 1, src)\n    ast_part_after  = @__parseSolidBlocks(block.lastIndex, end, src)\n\n    return [].concat(ast_part_before, block, ast_part_after)\n\n  # @private\n  # Parse the specified document region as a fluid block\n  # @param {Token} start_token The start token of a container block\n  # @param {string} src Markdown source\n  # @return [Array<Token>] AST of specified region\n  __parseFluidBlocks: (start_token, src) ->\n\n  # @private\n  # Match block rules from highest precedence to lowest against the specified\n  # document region and returns immediately on the first match.\n  # @param {int} begin Start index of the region\n  # @param {int} end Last index of the region\n  # @param {src} src Markdown source\n  # @return {Token} The first match\n  ___parseOneBlock: -> (begin, end, src) ->\n\n\n  # @private\n  # Parse inline elements\n  # @param {Array} ast AST with un-parsed block nodes only\n  # @return {Array} Fully parsed AST\n  _parseInline: (ast) ->\n"]}